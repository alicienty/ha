# -*- coding: utf-8 -*-
"""Лукьянчикова_bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sm-xffEfrUPIDu0nXT45pcENDOyhlElg

## Разработка Telegram-бота

### Критерии оценки
- создан файл bot.py (1 балл)
- в решении использована библиотека aiogram (1 балл)
- файл faq.json выгружен в переменную data (1 балл)
- реализован алгоритм выбора ответа (по правилам или с использованием эмбеддингов) (3 балла)
- добавлены 2 кнопки (1 балл за реализацию каждой кнопки)
- представлены скриншотом с демонстрацией работы кнопок и ответами бота (1 балл за скриншот с демонстрацией кнопок и 1 балл с демонстрацией ответов бота)
### Задание
1. Проходим туториал с прошлого семинара: https://github.com/vifirsanova/compling/blob/main/practice/tg_practice.ipynb

2. Создаём файл с названием bot.py

3. Создаём бота с помощью библиотеки aiogram согласно требованиям

**Требования для базового уровня**

1. Бот обрабатывает faq.json (в этом файле хранится словарь с частозадаваемыми вопросами)

  - файл хранится по ссылке `https://github.com/vifirsanova/compling/blob/main/tasks/task3/faq.json`
  - образец загрузки *.json вы найдете в ячейке ниже
  - вам нужно загрузить файл и сохранить его в `data`

2. Бот отвечает на вопросы по ключевым словам, которые получает от пользователя

  - список ключевых слов
    ```
    * Цены: "цены", "стоимость", "заказ", "оплата"
    * Часы работы: "часы работы", "время работы", "доступность"
    * Доставка: "доставка", "сроки доставки", "стоимость доставки", "отслеживание"
    * Возврат: "возврат", "обмен", "возврат товара", "гарантия"
    * Контакты: "связаться", "телефон", "email", "адрес"
    ```
  - если в запросе пользователя встречается одно из ключевых слов, бот возвращает подходящий ответ из документа `data`

3. Добавьте кнопки "О компании" и "Связаться с оператором"

  - при нажатии кнопки "О компании" бот выдает текст "Наша компания занимается доставкой товаров по всей стране."
  - при нажатии кнопки "Связаться с оператором" бот выдает текст "Перевожу на оператора..."

4. Запустите бот в Telegram, добавьте скриншоты, на которых продемонстрирована работа кнопок, а также пример одного ответа на вопрос пользователя

5. Удалите свой API-токен из файла `bot.py`

6. Добавьте в свой репозиторий файл `bot.py`

7. Добавьте в файл README.md скриншоты с образцом работы бота
"""

import json

with open('faq.json', encoding='utf-8') as f:
  data = json.load(f)

data

"""**Требования для продвинутого уровня**

1. Бот обрабатывает faq.json (в этом файле хранится словарь с частозадаваемыми вопросами)

  - файл хранится по ссылке `https://github.com/vifirsanova/compling/blob/main/tasks/task3/faq.json`
  - образец загрузки *.json вы найдете в ячейке ниже
  - вам нужно загрузить файл и сохранить его в `data`

2. Бот выбирает наиболее подходящий ответ на вопросы пользователя на основе оценки семантического сходства (см. образец в ячейке ниже)

  - реализуйте 2 базовых метода: TF-IDF и Word2Vec
  - эти методы строят векторные представления для запросов и возможных вариантов ответа, а потом выбирают наиболее подходящий ответ на основе косинусного сходства

3. Добавьте кнопки "О компании" и "Пожаловаться"

  - при нажатии кнопки "О компании" бот выдает текст "Наша компания занимается доставкой товаров по всей стране."
  - при нажатии кнопки "Пожаловаться" бот принимает на вход картинку (например, скриншот) и возвращает её название и размер файла, а также текст "Ваш запрос передан специалисту"

4. Запустите бот в Telegram, добавьте скриншоты, на которых продемонстрирована работа кнопок, а также пример одного ответа на вопрос пользователя

5. Удалите свой API-токен из файла `bot.py`

6. Добавьте в свой репозиторий файл `bot.py`

7. Добавьте в файл README.md скриншоты с образцом работы бота
"""

!pip install aiogram scikit-learn gensim numpy requests

import json
import requests
import asyncio
import numpy as np
from aiogram import Bot, Dispatcher, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Command
from aiogram.types import Message
from aiogram.enums import ContentType
from aiogram.fsm.storage.memory import MemoryStorage
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from gensim.models import Word2Vec

# Импортируем необходимые модули
from aiogram import Bot, Dispatcher, types  # Основные классы для работы с ботом
import logging  # Логирование для отслеживания работы бота
import asyncio  # Модуль для работы с асинхронным кодом
import sys  # Используется для работы с системными вызовами

# Токен API бота (его нужно заменить на реальный токен, полученный у BotFather)
API_TOKEN = "token"

# Настраиваем логирование, чтобы видеть информацию о работе бота в консоли
logging.basicConfig(level=logging.INFO)
# Создаем объект диспетчера, который управляет входящими сообщениями и командами
dp = Dispatcher()

bot = Bot(token=API_TOKEN)

# Загружаем json
faq_url = "https://raw.githubusercontent.com/vifirsanova/compling/main/tasks/task3/faq.json"
faq_data = requests.get(faq_url).json()["faq"]

faq_questions = [item["question"] for item in faq_data]
faq_answers = [item["answer"] for item in faq_data]

"""tf-idf"""

# TF-IDF преобразование
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(faq_questions)

# Запрос пользователя
query = "Где мой заказ?"

# Преобразуем запрос в вектор
query_vec = vectorizer.transform([query])

# Вычисляем косинусное сходство
similarities = cosine_similarity(query_vec, tfidf_matrix)

# Ищем индекс наиболее близкого вопроса на основе косинусного сходства
best_match_idx = similarities.argmax()
best_question = faq_questions[best_match_idx]
best_answer = faq_answers[best_match_idx]

# Выводим результат
print(f"Вопрос: {best_question}")
print(f"Ответ: {best_answer}")

"""word2vec"""

# Подгружаем Word2Vec
sentences = [q.split() for q in faq_questions]
word2vec_model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4)

# Функция для усреднения векторов слов в вопросе
def sentence_vector(sentence, model):
    words = sentence.split()
    vectors = [model.wv[word] for word in words if word in model.wv]
    return np.mean(vectors, axis=0) # Берем среднее значение по всем векторам, чтобы одно предложение представлял один вектор

# Векторизуем вопросы
faq_vectors = np.array([sentence_vector(q, model) for q in faq_questions])

# Образец запроса пользователя
query = "Где мой заказ?"
query_vector = sentence_vector(query, model).reshape(1, -1)

# Оценка косинусного сходства
similarities = cosine_similarity(query_vector, faq_vectors)
best_match_idx = similarities.argmax()
best_answer = faq_answers[best_match_idx]

print(f"Вопрос: {faq_questions[best_match_idx]}")
print(f"Ответ: {best_answer}")

"""Функция сравнения и выбора лучшего ответа для бота"""

# Функция выбора ответа
def get_best_answer(query):
    query_vec_tfidf = vectorizer.transform([query])
    similarities_tfidf = cosine_similarity(query_vec_tfidf, tfidf_matrix)
    best_match_idx_tfidf = similarities_tfidf.argmax()

    query_vec_w2v = sentence_vector(query, word2vec_model).reshape(1, -1)
    similarities_w2v = cosine_similarity(query_vec_w2v, faq_vectors)
    best_match_idx_w2v = similarities_w2v.argmax()

    if best_match_idx_tfidf == best_match_idx_w2v:
        return faq_answers[best_match_idx_tfidf]

    best_match_idx = best_match_idx_tfidf if similarities_tfidf.max() > similarities_w2v.max() else best_match_idx_w2v
    return faq_answers[best_match_idx]

    """ Функция get_best_answer(query) выбирает наиболее подходящий ответ на вопрос пользователя, сравнивая два метода """

query = "Когда доставят мой заказ?"
print(get_best_answer(query))

"""Кнопки"""

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

# Создаём кнопки
kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="О компании")],
        [KeyboardButton(text="Пожаловаться")]
    ],
    resize_keyboard=True
)

# Обрабатываем команды
@dp.message(Command("start"))
async def start(message: Message):
    await message.answer("Привет! Я бот, отвечающий на вопросы. Выберите кнопку или задайте свой вопрос.", reply_markup=kb)

@dp.message(lambda message: message.text == "О компании")
async def about_company(message: Message):
    await message.answer("Наша компания занимается доставкой товаров по всей стране.")

@dp.message(lambda message: message.text == "Пожаловаться")
async def complain(message: Message):
    await message.answer("Отправьте изображение с жалобой.")
"""
@dp.message(lambda message: message.content_type == ContentType.PHOTO)
async def handle_photo(message: Message):
    photo = message.photo[-1]
    file_info = await bot.get_file(photo.file_id)
    file_size = file_info.file_size

    await message.answer(f"Ваш запрос передан специалисту.\nРазмер файла: {file_size} байт")"""

@dp.message(lambda message: message.content_type == ContentType.PHOTO)
async def handle_photo(message: Message):
    photo = message.photo[-1]
    file_info = await message.bot.get_file(photo.file_id)
    file_size = file_info.file_size
    file_name = file_info.file_name

    await message.answer(f"Название файла: {file_name}\nРазмер файла: {file_size} байт")
    await message.answer("Ваш запрос передан специалисту.")

# Обработка вопросов
@dp.message()
async def handle_question(message: Message):
    user_question = message.text
    answer = get_best_answer(user_question)
    await message.answer(answer)

# Запуск бота
async def main():
    bot = Bot(token=API_TOKEN)
    await dp.start_polling(bot)

if __name__ == "__main__":
    await main()

# 1. Загружаем библиотеки для векторизации и оценки косинусного сходства
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# 2. Образец списка вопросов: замените на этот пример на автоматическое извлечение данных из переменной data
faq_questions = [
    "Каковы ваши цены?", "Какие способы оплаты вы принимаете?", "В какие часы работает ваш магазин?",
    "Как связаться с вами?", "Как осуществляется доставка?", "Какая ваша политика возврата?",
    "Где вы находитесь?", "Как я могу отследить свой заказ?"
]

faq_answers = [
    "Наши цены конкурентоспособны...", "Мы принимаем к оплате банковские карты...",
    "Наш интернет-магазин работает круглосуточно...", "Вы можете связаться с нами по телефону...",
    "Мы сотрудничаем с курьерскими службами...", "Вы можете вернуть товар в течение 14 дней...",
    "Мы интернет-магазин и не имеем физического магазина...", "После отправки заказа вы получите письмо..."
]

# TF-IDF преобразование
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(faq_questions)

# Запрос пользователя
query = "Где мой заказ?"

# Преобразуем запрос в вектор
query_vec = vectorizer.transform([query])

# Вычисляем косинусное сходство
similarities = cosine_similarity(query_vec, tfidf_matrix)

# Ищем индекс наиболее близкого вопроса на основе косинусного сходства
best_match_idx = similarities.argmax()
best_answer = faq_answers[best_match_idx]

print(f"Вопрос: {faq_questions[best_match_idx]}")
print(f"Ответ: {best_answer}")

# Загрузка Word2Vec из Gensim
import gensim
import numpy as np
from gensim.models import Word2Vec
from sklearn.metrics.pairwise import cosine_similarity

# Подгружаем Word2Vec
sentences = [q.split() for q in faq_questions]
model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4)

# Функция для усреднения векторов слов в вопросе
def sentence_vector(sentence, model):
    words = sentence.split()
    vectors = [model.wv[word] for word in words if word in model.wv]
    return np.mean(vectors, axis=0) # Берем среднее значение по всем векторам, чтобы одно предложение представлял один вектор

# Векторизуем вопросы
faq_vectors = np.array([sentence_vector(q, model) for q in faq_questions])

# Образец запроса пользователя
query = "Где мой заказ?"
query_vector = sentence_vector(query, model).reshape(1, -1)

# Оценка косинусного сходства
similarities = cosine_similarity(query_vector, faq_vectors)
best_match_idx = similarities.argmax()
best_answer = faq_answers[best_match_idx]

print(f"Вопрос: {faq_questions[best_match_idx]}")
print(f"Ответ: {best_answer}")

